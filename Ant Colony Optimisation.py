# -*- coding: utf-8 -*-
"""CNLABEXAM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xJQ-X-jhnA6lBthGIYLF7NNl_DjY9Owc
"""

import random

class Network:
    def __init__(self):
        self.nodes = set()
        self.links = {}

    def add_node(self, node):
        self.nodes.add(node)

    def add_link(self, node1, node2, cost):
        self.links[(node1, node2)] = cost
        self.links[(node2, node1)] = cost

    def get_neighbors(self, node):
        neighbors = []
        for link in self.links:
            if link[0] == node:
                neighbors.append(link[1])
            elif link[1] == node:
                neighbors.append(link[0])
        return neighbors

    def get_link_cost(self, node1, node2):
        return self.links[(node1, node2)]


class AntColonyOptimization:
    def __init__(self, network, num_ants, evaporation_rate, alpha, beta, pheromone_init):
        self.network = network
        self.num_ants = num_ants
        self.evaporation_rate = evaporation_rate
        self.alpha = alpha
        self.beta = beta
        self.pheromone_init = pheromone_init
        self.pheromone_matrix = None

    def initialize_pheromone_matrix(self):
        self.pheromone_matrix = {}
        for node1 in self.network.nodes:
            self.pheromone_matrix[node1] = {}
            for node2 in self.network.nodes:
                if node1 == node2:
                    self.pheromone_matrix[node1][node2] = 0.0
                else:
                    self.pheromone_matrix[node1][node2] = self.pheromone_init

    def update_pheromone_matrix(self, ant_routes):
        for node1 in self.network.nodes:
            for node2 in self.network.nodes:
                if node1 != node2:
                    self.pheromone_matrix[node1][node2] *= (1 - self.evaporation_rate)
        for route in ant_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                self.pheromone_matrix[node1][node2] += 1.0 / self.network.get_link_cost(node1, node2)

    def select_next_node(self, ant, current_node, available_nodes):
        probabilities = []
        total = 0.0
        for node in available_nodes:
            pheromone = self.pheromone_matrix[current_node][node]
            distance = 1.0 / self.network.get_link_cost(current_node, node)
            probability = (pheromone ** self.alpha) * (distance ** self.beta)
            probabilities.append(probability)
            total += probability
        probabilities = [p / total for p in probabilities]
        selected_index = self.roulette_wheel_selection(probabilities)
        return available_nodes[selected_index]

    def roulette_wheel_selection(self, probabilities):
        cumulative_probabilities = [sum(probabilities[:i+1]) for i in range(len(probabilities))]
        random_value = random.uniform(0, 1)
        for i in range(len(cumulative_probabilities)):
            if random_value <= cumulative_probabilities[i]:
                return i

    def find_shortest_path(self, source, destination):
        shortest_path = None
        shortest_distance = float('inf')
        for ant in range(self.num_ants):
            current_node = source
            visited_nodes = set([source])
            path = [source]
            distance = 0
            while current_node != destination:
                available_nodes = list(set(self.network.get_neighbors(current_node)) - visited_nodes)
                if not available_nodes:
                    break
                next_node = self.select_next_node(ant, current_node, available_nodes)
                distance += self.network.get_link_cost(current_node, next_node)
                current_node = next_node
                visited_nodes.add(current_node)
                path.append(current_node)
            if current_node == destination and distance < shortest_distance:
                shortest_distance = distance
                shortest_path = path
        return shortest_path, shortest_distance


# Define the network topology
network = Network()
network.add_node('A')
network.add_node('B')
network.add_node('C')
network.add_node('D')
network.add_node('E')
network.add_node('F')

network.add_link('A', 'B', 2)
network.add_link('A', 'C', 4)
network.add_link('B', 'C', 3)
network.add_link('B', 'D', 2)
network.add_link('C', 'D', 1)
network.add_link('C', 'E', 4)
network.add_link('D', 'E', 2)
network.add_link('D', 'F', 3)
network.add_link('E', 'F', 2)

# Create and run Ant Colony Optimization
aco = AntColonyOptimization(network, num_ants=5, evaporation_rate=0.5, alpha=1.0, beta=2.0, pheromone_init=0.1)
aco.initialize_pheromone_matrix()
shortest_path, shortest_distance = aco.find_shortest_path('A', 'F')

# Print the shortest path and distance
if shortest_path is not None:
    print("Shortest Path:", ' -> '.join(shortest_path))
    print("Shortest Distance:", shortest_distance)
else:
    print("Destination is unreachable.")

import networkx as nx
import matplotlib.pyplot as plt

import random

class Network:
    def __init__(self):
        self.nodes = set()
        self.links = {}

    def add_node(self, node):
        self.nodes.add(node)

    def add_link(self, node1, node2, cost, latency, throughput, packet_loss):
        self.links[(node1, node2)] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }
        self.links[(node2, node1)] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }

    def get_neighbors(self, node):
        neighbors = []
        for link in self.links:
            if link[0] == node:
                neighbors.append(link[1])
            elif link[1] == node:
                neighbors.append(link[0])
        return neighbors

    def get_link_cost(self, node1, node2):
        return self.links[(node1, node2)]['cost']

    def get_link_latency(self, node1, node2):
        return self.links[(node1, node2)]['latency']

    def get_link_throughput(self, node1, node2):
        return self.links[(node1, node2)]['throughput']

    def get_link_packet_loss(self, node1, node2):
        return self.links[(node1, node2)]['packet_loss']


class AntColonyOptimization:
    def __init__(self, network, num_ants, evaporation_rate, alpha, beta, pheromone_init):
        self.network = network
        self.num_ants = num_ants
        self.evaporation_rate = evaporation_rate
        self.alpha = alpha
        self.beta = beta
        self.pheromone_init = pheromone_init
        self.pheromone_matrix = None

    def initialize_pheromone_matrix(self):
        self.pheromone_matrix = {}
        for node1 in self.network.nodes:
            self.pheromone_matrix[node1] = {}
            for node2 in self.network.nodes:
                if node1 == node2:
                    self.pheromone_matrix[node1][node2] = 0.0
                else:
                    self.pheromone_matrix[node1][node2] = self.pheromone_init

    def update_pheromone_matrix(self, ant_routes):
        for node1 in self.network.nodes:
            for node2 in self.network.nodes:
                if node1 != node2:
                    self.pheromone_matrix[node1][node2] *= (1 - self.evaporation_rate)
        for route in ant_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                pheromone = 1.0 / (
                        self.network.get_link_cost(node1, node2) *
                        self.network.get_link_latency(node1, node2) *
                        self.network.get_link_throughput(node1, node2) *
                        (1.0 - self.network.get_link_packet_loss(node1, node2))
                )
                self.pheromone_matrix[node1][node2] += pheromone

    def select_next_node(self, ant, current_node, available_nodes):
        probabilities = []
        total = 0.0
        for node in available_nodes:
            pheromone = self.pheromone_matrix[current_node][node]
            cost = self.network.get_link_cost(current_node, node)
            latency = self.network.get_link_latency(current_node, node)
            throughput = self.network.get_link_throughput(current_node, node)
            packet_loss = self.network.get_link_packet_loss(current_node, node)
            probability = (
                    (pheromone ** self.alpha) *
                    ((1.0 / cost) ** self.beta) *
                    ((1.0 / latency) ** self.beta) *
                    (throughput ** self.alpha) *
                    ((1.0 - packet_loss) ** self.alpha)
            )
            probabilities.append(probability)
            total += probability
        probabilities = [p / total for p in probabilities]
        selected_index = self.roulette_wheel_selection(probabilities)
        return available_nodes[selected_index]

    def roulette_wheel_selection(self, probabilities):
        cumulative_probabilities = [sum(probabilities[:i + 1]) for i in range(len(probabilities))]
        random_value = random.uniform(0, 1)
        for i in range(len(cumulative_probabilities)):
            if random_value <= cumulative_probabilities[i]:
                return i

    def find_shortest_path(self, source, destination):
        shortest_path = None
        shortest_distance = float('inf')
        for ant in range(self.num_ants):
            current_node = source
            visited_nodes = set([source])
            path = [source]
            distance = 0
            while current_node != destination:
                available_nodes = list(set(self.network.get_neighbors(current_node)) - visited_nodes)
                if not available_nodes:
                    break
                next_node = self.select_next_node(ant, current_node, available_nodes)
                distance += self.network.get_link_cost(current_node, next_node)
                current_node = next_node
                visited_nodes.add(current_node)
                path.append(current_node)
            if current_node == destination and distance < shortest_distance:
                shortest_distance = distance
                shortest_path = path
        return shortest_path, shortest_distance


class PerformanceMetrics:
    @staticmethod
    def calculate_end_to_end_delay(path, network):
        total_delay = 0
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            latency = network.get_link_latency(node1, node2)
            total_delay += latency
        return total_delay

    @staticmethod
    def calculate_network_congestion(path, network):
        max_throughput = float('inf')
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            throughput = network.get_link_throughput(node1, node2)
            if throughput < max_throughput:
                max_throughput = throughput
        return max_throughput


def run_iterations(starting_nodes, increment, num_iterations):
    iterations = []
    for i in range(num_iterations):
        num_nodes = starting_nodes + (i * increment)

        # Define the network topology with latency, throughput, and packet loss information
        network = Network()
        for j in range(num_nodes):
            node = chr(ord('A') + j)
            network.add_node(node)

        # Add links randomly with random costs, latencies, throughputs, and packet losses
        for j in range(num_nodes - 1):
            node1 = chr(ord('A') + j)
            node2 = chr(ord('A') + j + 1)
            cost = random.randint(1, 10)
            latency = random.randint(5, 20)
            throughput = random.randint(50, 200)
            packet_loss = random.uniform(0.01, 0.1)
            network.add_link(node1, node2, cost=cost, latency=latency, throughput=throughput, packet_loss=packet_loss)

        # Create and run Ant Colony Optimization
        aco = AntColonyOptimization(network, num_ants=9, evaporation_rate=0.5, alpha=1.0, beta=2.0, pheromone_init=0.1)
        aco.initialize_pheromone_matrix()
        shortest_path, shortest_distance = aco.find_shortest_path('A', chr(ord('A') + num_nodes - 1))

        # Store the results (delay, congestion) for this iteration
        if shortest_path is not None:
            end_to_end_delay = PerformanceMetrics.calculate_end_to_end_delay(shortest_path, network)
            network_congestion = PerformanceMetrics.calculate_network_congestion(shortest_path, network)
            iterations.append((end_to_end_delay, network_congestion))
        else:
            iterations.append((float('inf'), float('inf')))

    return iterations


# Run iterations and store the results
starting_nodes = 7
increment = 10
num_iterations = 10
results = run_iterations(starting_nodes, increment, num_iterations)

# Print the results
for i, (delay, congestion) in enumerate(results):
    num_nodes = starting_nodes + (i * increment)
    print(f"Iteration {i+1}: Number of Nodes = {num_nodes}, Delay = {delay}, Congestion = {congestion}")

# Plot the results
x = range(starting_nodes, starting_nodes + (increment * num_iterations), increment)
y_delay = [delay for delay, _ in results]
y_congestion = [congestion for _, congestion in results]

plt.plot(x, y_delay, label="Delay")
plt.xlabel("Number of Nodes")
plt.ylabel("Delay")
plt.title("Performance Metrics vs. Number of Nodes")
plt.legend()
plt.show()

import heapq
from collections import defaultdict

class Network:
    def __init__(self):
        self.nodes = set()
        self.links = defaultdict(dict)

    def add_node(self, node):
        self.nodes.add(node)

    def add_link(self, node1, node2, cost, latency, throughput, packet_loss):
        self.links[node1][node2] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }
        self.links[node2][node1] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }

    def get_neighbors(self, node):
        return list(self.links[node].keys())

    def get_link_cost(self, node1, node2):
        return self.links[node1][node2]['cost']

    def get_link_latency(self, node1, node2):
        return self.links[node1][node2]['latency']

    def get_link_throughput(self, node1, node2):
        return self.links[node1][node2]['throughput']

    def get_link_packet_loss(self, node1, node2):
        return self.links[node1][node2]['packet_loss']


class PerformanceMetrics:
    @staticmethod
    def calculate_end_to_end_delay(path, network):
        total_delay = 0
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            latency = network.get_link_latency(node1, node2)
            total_delay += latency
        return total_delay

    @staticmethod
    def calculate_network_congestion(path, network):
        max_throughput = float('inf')
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            throughput = network.get_link_throughput(node1, node2)
            if throughput < max_throughput:
                max_throughput = throughput
        return max_throughput



def ospf_shortest_path(network, source, destination):
    # Dijkstra's algorithm
    queue = [(0, source)]
    visited = set()
    distance = {source: 0}
    previous = {}

    while queue:
        dist, node = heapq.heappop(queue)

        if node == destination:
            break

        if node in visited:
            continue

        visited.add(node)

        for neighbor in network.get_neighbors(node):
            cost = network.get_link_cost(node, neighbor)
            new_dist = dist + cost

            if neighbor not in distance or new_dist < distance[neighbor]:
                distance[neighbor] = new_dist
                previous[neighbor] = node
                heapq.heappush(queue, (new_dist, neighbor))

    if destination not in distance:
        return None

    # Reconstruct the path
    path = [destination]
    while path[-1] != source:
        path.append(previous[path[-1]])
    path.reverse()

    return path


# Create the network
network = Network()
network.add_node('A')
network.add_node('B')
network.add_node('C')
network.add_node('D')
network.add_node('E')
network.add_node('F')
network.add_node('G')

network.add_link('A', 'B', cost=2, latency=10, throughput=100, packet_loss=0.05)
network.add_link('A', 'C', cost=4, latency=15, throughput=200, packet_loss=0.1)
network.add_link('B', 'C', cost=3, latency=12, throughput=150, packet_loss=0.07)
network.add_link('B', 'D', cost=2, latency=8, throughput=120, packet_loss=0.03)
network.add_link('C', 'D', cost=1, latency=5, throughput=180, packet_loss=0.02)
network.add_link('D', 'E', cost=3, latency=9, throughput=160, packet_loss=0.08)
network.add_link('D', 'F', cost=4, latency=13, throughput=140, packet_loss=0.04)
network.add_link('E', 'F', cost=2, latency=7, throughput=130, packet_loss=0.06)
network.add_link('E', 'G', cost=3, latency=11, throughput=110, packet_loss=0.09)
network.add_link('F', 'G', cost=1, latency=6, throughput=170, packet_loss=0.03)

# Perform OSPF shortest path calculation
source = 'A'
destination = 'G'
path = ospf_shortest_path(network, source, destination)

if path:
    print("Shortest path:", ' -> '.join(path))
    total_cost = sum(network.get_link_cost(path[i], path[i+1]) for i in range(len(path)-1))
    print("Total path cost:", total_cost)
    print("Metrics:")
    print("End-to-end delay:", PerformanceMetrics.calculate_end_to_end_delay(path, network))
    print("Network congestion:", PerformanceMetrics.calculate_network_congestion(path, network))

else:
    print("No path found from", source, "to", destination)
print('OSPF')

#Graph Plotting
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
G = nx.Graph()

# Add nodes
nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
G.add_nodes_from(nodes)

# Add edges with attributes
edges = [
    ('A', 'B', {'cost': 2, 'latency': 10, 'throughput': 100, 'packet_loss': 0.05}),
    ('A', 'C', {'cost': 4, 'latency': 15, 'throughput': 200, 'packet_loss': 0.1}),
    ('B', 'C', {'cost': 3, 'latency': 12, 'throughput': 150, 'packet_loss': 0.07}),
    ('B', 'D', {'cost': 2, 'latency': 8, 'throughput': 120, 'packet_loss': 0.03}),
    ('C', 'D', {'cost': 1, 'latency': 5, 'throughput': 180, 'packet_loss': 0.02}),
    ('D', 'E', {'cost': 3, 'latency': 9, 'throughput': 160, 'packet_loss': 0.08}),
    ('D', 'F', {'cost': 4, 'latency': 13, 'throughput': 140, 'packet_loss': 0.04}),
    ('E', 'F', {'cost': 2, 'latency': 7, 'throughput': 130, 'packet_loss': 0.06}),
    ('E', 'G', {'cost': 3, 'latency': 11, 'throughput': 110, 'packet_loss': 0.09}),
    ('F', 'G', {'cost': 1, 'latency': 6, 'throughput': 170, 'packet_loss': 0.03})
]
G.add_edges_from(edges)

# Plot the graph
# Plot the graph
fig = plt.figure(figsize=(20, 12))  # Adjust the figure size (width, height)
pos = nx.spring_layout(G)  # Layout for node positioning
edge_labels = {(u, v): f"Cost: {d['cost']}\nLatency: {d['latency']}\nThroughput: {d['throughput']}\nPacket Loss: {d['packet_loss']}" for u, v, d in G.edges(data=True)}
nx.draw_networkx(G, pos, with_labels=True, node_color='skyblue', node_size=1000, edge_color='gray', width=1.5)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')
plt.axis('off')

# Change the color of nodes A and G to red
node_colors = ['red' if node in ['A', 'G'] else 'skyblue' for node in G.nodes()]
nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=1000)
plt.show()

#with metrics
import random


class Network:
    def __init__(self):
        self.nodes = set()
        self.links = {}

    def add_node(self, node):
        self.nodes.add(node)

    def add_link(self, node1, node2, cost, latency, throughput, packet_loss):
        self.links[(node1, node2)] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }
        self.links[(node2, node1)] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }

    def get_neighbors(self, node):
        neighbors = []
        for link in self.links:
            if link[0] == node:
                neighbors.append(link[1])
            elif link[1] == node:
                neighbors.append(link[0])
        return neighbors

    def get_link_cost(self, node1, node2):
        return self.links[(node1, node2)]['cost']

    def get_link_latency(self, node1, node2):
        return self.links[(node1, node2)]['latency']

    def get_link_throughput(self, node1, node2):
        return self.links[(node1, node2)]['throughput']

    def get_link_packet_loss(self, node1, node2):
        return self.links[(node1, node2)]['packet_loss']


class AntColonyOptimization:
    def __init__(self, network, num_ants, evaporation_rate, alpha, beta, pheromone_init):
        self.network = network
        self.num_ants = num_ants
        self.evaporation_rate = evaporation_rate
        self.alpha = alpha
        self.beta = beta
        self.pheromone_init = pheromone_init
        self.pheromone_matrix = None

    def initialize_pheromone_matrix(self):
        self.pheromone_matrix = {}
        for node1 in self.network.nodes:
            self.pheromone_matrix[node1] = {}
            for node2 in self.network.nodes:
                if node1 == node2:
                    self.pheromone_matrix[node1][node2] = 0.0
                else:
                    self.pheromone_matrix[node1][node2] = self.pheromone_init

    def update_pheromone_matrix(self, ant_routes):
        for node1 in self.network.nodes:
            for node2 in self.network.nodes:
                if node1 != node2:
                    self.pheromone_matrix[node1][node2] *= (1 - self.evaporation_rate)
        for route in ant_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i + 1]
                pheromone = 1.0 / (
                        self.network.get_link_cost(node1, node2) *
                        self.network.get_link_latency(node1, node2) *
                        self.network.get_link_throughput(node1, node2) *
                        (1.0 - self.network.get_link_packet_loss(node1, node2))
                )
                self.pheromone_matrix[node1][node2] += pheromone

    def select_next_node(self, ant, current_node, available_nodes):
        probabilities = []
        total = 0.0
        for node in available_nodes:
            pheromone = self.pheromone_matrix[current_node][node]
            cost = self.network.get_link_cost(current_node, node)
            latency = self.network.get_link_latency(current_node, node)
            throughput = self.network.get_link_throughput(current_node, node)
            packet_loss = self.network.get_link_packet_loss(current_node, node)
            probability = (
                    (pheromone ** self.alpha) *
                    ((1.0 / cost) ** self.beta) *
                    ((1.0 / latency) ** self.beta) *
                    (throughput ** self.alpha) *
                    ((1.0 - packet_loss) ** self.alpha)
            )
            probabilities.append(probability)
            total += probability
        probabilities = [p / total for p in probabilities]
        selected_index = self.roulette_wheel_selection(probabilities)
        return available_nodes[selected_index]

    def roulette_wheel_selection(self, probabilities):
        cumulative_probabilities = [sum(probabilities[:i + 1]) for i in range(len(probabilities))]
        random_value = random.uniform(0, 1)
        for i in range(len(cumulative_probabilities)):
            if random_value <= cumulative_probabilities[i]:
                return i

    def find_shortest_path(self, source, destination):
        shortest_path = None
        shortest_distance = float('inf')
        for ant in range(self.num_ants):
            current_node = source
            visited_nodes = set([source])
            path = [source]
            distance = 0
            while current_node != destination:
                available_nodes = list(set(self.network.get_neighbors(current_node)) - visited_nodes)
                if not available_nodes:
                    break
                next_node = self.select_next_node(ant, current_node, available_nodes)
                distance += self.network.get_link_cost(current_node, next_node)
                current_node = next_node
                visited_nodes.add(current_node)
                path.append(current_node)
            if current_node == destination and distance < shortest_distance:
                shortest_distance = distance
                shortest_path = path
        return shortest_path, shortest_distance


class PerformanceMetrics:
    @staticmethod
    def calculate_end_to_end_delay(path, network):
        total_delay = 0
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            latency = network.get_link_latency(node1, node2)
            total_delay += latency
        return total_delay

    @staticmethod
    def calculate_network_congestion(path, network):
        max_throughput = float('inf')
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            throughput = network.get_link_throughput(node1, node2)
            if throughput < max_throughput:
                max_throughput = throughput
        return max_throughput




# Define the network topology with latency, throughput, and packet loss information
network = Network()
network.add_node('A')
network.add_node('B')
network.add_node('C')
network.add_node('D')
network.add_node('E')
network.add_node('F')
network.add_node('G')

network.add_link('A', 'B', cost=2, latency=10, throughput=100, packet_loss=0.05)
network.add_link('A', 'C', cost=4, latency=15, throughput=200, packet_loss=0.1)
network.add_link('B', 'C', cost=3, latency=12, throughput=150, packet_loss=0.07)
network.add_link('B', 'D', cost=2, latency=8, throughput=120, packet_loss=0.03)
network.add_link('C', 'D', cost=1, latency=5, throughput=180, packet_loss=0.02)
network.add_link('D', 'E', cost=3, latency=9, throughput=160, packet_loss=0.08)
network.add_link('D', 'F', cost=4, latency=13, throughput=140, packet_loss=0.04)
network.add_link('E', 'F', cost=2, latency=7, throughput=130, packet_loss=0.06)
network.add_link('E', 'G', cost=3, latency=11, throughput=110, packet_loss=0.09)
network.add_link('F', 'G', cost=1, latency=6, throughput=170, packet_loss=0.03)

# Create and run Ant Colony Optimization
aco = AntColonyOptimization(network, num_ants=9, evaporation_rate=0.5, alpha=1.0, beta=2.0, pheromone_init=0.1)
aco.initialize_pheromone_matrix()
shortest_path, shortest_distance = aco.find_shortest_path('A', 'G')

# Print the shortest path and distance
if shortest_path is not None:
    print("Shortest Path:", ' -> '.join(shortest_path))
    print("Shortest Distance:", shortest_distance)

    # Calculate performance metrics
    end_to_end_delay = PerformanceMetrics.calculate_end_to_end_delay(shortest_path, network)
    network_congestion = PerformanceMetrics.calculate_network_congestion(shortest_path, network)

    print("End-to-End Delay:", end_to_end_delay)
    print("Network Congestion:", network_congestion)
else:
    print("Destination is unreachable.")

import random
import matplotlib.pyplot as plt

# Number of iterations
num_iterations = 10

# Number of links
num_links = 10

# Generate sample pheromone values for each link over iterations
pheromone_values = [[] for _ in range(num_links)]  # List of empty lists for each link

pheromone_init = 0.3  # Initial pheromone value
decay_rate = 0.25  # Decay rate
random_range = (-0.1, 0.1)  # Random range for variation

for iteration in range(num_iterations):
    for link in range(num_links):
        # Calculate the current pheromone value for the link
        if iteration == 0:
            current_pheromone = pheromone_init  # Initial pheromone value
        else:
            previous_pheromone = pheromone_values[link][iteration - 1]
            variation = (1 - decay_rate) * previous_pheromone + random.uniform(*random_range)
            current_pheromone = max(0, variation)  # Ensure non-negative pheromone value

        # Append the current pheromone to the list for the link
        pheromone_values[link].append(current_pheromone)

# Plotting the pheromone values for each link
iterations = range(1, num_iterations + 1)

plt.figure(figsize=(20, 12))  # Set the figure size

link_names = ['A-B', 'A-C', 'B-C', 'B-D', 'C-D', 'D-E', 'D-F', 'E-F', 'E-G', 'F-G']

for link in range(num_links):
    plt.plot(iterations, pheromone_values[link], marker='o', label=f'Link {link_names[link]}')

plt.xlabel('Iterations')
plt.ylabel('Pheromone')
plt.title('Pheromone Variation over Iterations')
plt.legend()
plt.grid(True)
plt.show()

import sys
import time

class RIPRouter:
    def __init__(self, router_id):
        self.router_id = router_id
        self.routing_table = {}  # Dictionary to store the routing table
        self.neighbors = {}  # Dictionary to store the neighbor routers and their costs

    def add_neighbor(self, neighbor_id, cost):
        self.neighbors[neighbor_id] = cost

    def receive_routing_table(self, sender_id, routing_table):
        # Update the routing table with the received routing table from a neighbor
        for destination, cost in routing_table.items():
            if destination == self.router_id:
                continue  # Skip updating the entry for the current router

            # Calculate the total cost to the destination via the sender
            total_cost = self.neighbors[sender_id] + cost

            if destination not in self.routing_table or total_cost < self.routing_table[destination]:
                # Update or add the entry in the routing table
                self.routing_table[destination] = total_cost

    def send_routing_table(self):
        # Broadcast the routing table to all the neighbors
        for neighbor_id in self.neighbors:
            neighbor_router = routers[neighbor_id]
            neighbor_router.receive_routing_table(self.router_id, self.routing_table)

    def print_routing_table(self):
        print(f"Routing table for Router {self.router_id}:")
        print("Destination\tCost")

        for destination, cost in self.routing_table.items():
            print(f"{destination}\t\t{cost}")

        print()

# Create router instances
routers = {
    'A': RIPRouter('A'),
    'B': RIPRouter('B'),
    'C': RIPRouter('C'),
    'D': RIPRouter('D'),
}

# Set up the network topology
routers['A'].add_neighbor('B', 1)
routers['A'].add_neighbor('C', 5)
routers['B'].add_neighbor('A', 1)
routers['B'].add_neighbor('C', 2)
routers['B'].add_neighbor('D', 3)
routers['C'].add_neighbor('A', 5)
routers['C'].add_neighbor('B', 2)
routers['C'].add_neighbor('D', 2)
routers['D'].add_neighbor('B', 3)
routers['D'].add_neighbor('C', 2)

# Set initial routing tables
for router in routers.values():
    router.routing_table[router.router_id] = 0

# Run the RIP algorithm
num_iterations = 5

for iteration in range(num_iterations):
    print(f"Iteration {iteration + 1}")
    print("----------------------")

    for router in routers.values():
        router.send_routing_table()

    for router in routers.values():
        router.print_routing_table()

    print("----------------------")
    time.sleep(1)  # Pause between iterations

# Example output for 5 iterations:
# Iteration 1
# ----------------------
# Routing table for Router A:
# Destination    Cost
# A               0
# B               1
# C               3
# D               5
#
# Routing table for Router B:
# Destination    Cost
# A               1
# B               0
# C               2
# D               3
#
# Routing table for Router C:
# Destination    Cost
# A               3
# B               2
# C               0
# D               2
#
# Routing table for Router D:
# Destination    Cost
# A               5
# B               3
# C               2
# D               0
#
# ----------------------
# Iteration 2
# ...
# ```

import random
import numpy as np
import matplotlib.pyplot as plt


num_iterations = 10
num_links = 10

pheromone_values = [[] for _ in range(num_links)]

pheromone_init = 0.3
decay_rate = 0.25
random_range = (-.5,.5)

link_properties = np.array([
    [2, 10, 50, 0.05],
    [4, 15, 325, 0.1],
    [3, 12, 60, 0.07],
    [2, 8, 420, 0.03],
    [1, 5, 50, 0.02],
    [3, 9, 65, 0.08],
    [4, 13, 800, 0.04],
    [2, 7, 770, 0.06],
    [3, 11, 55, 0.09],
    [1, 6, 600, 0.03]
])

for iteration in range(num_iterations):
    for link in range(num_links):
        if iteration == 0:
            current_pheromone = pheromone_init
        else:
            previous_pheromone = pheromone_values[link][iteration - 1]
            cost, latency, throughput, packet_loss = link_properties[link]
            variation = (1 - decay_rate) * previous_pheromone + 20 / throughput +random.uniform(*random_range)
            current_pheromone = max(0, variation)

        pheromone_values[link].append(current_pheromone)

iterations = range(1, num_iterations + 1)

plt.figure(figsize=(18, 10))  # Set the figure size

link_names = ['A-B', 'A-C', 'B-C', 'B-D', 'C-D', 'D-E', 'D-F', 'E-F', 'E-G', 'F-G']

for link in range(num_links):
    plt.plot(iterations, pheromone_values[link], marker='o', label=f'Link {link_names[link]}')

plt.xlabel('Iterations')
plt.ylabel('Pheromone')
plt.title('Pheromone Variation over Iterations')
plt.legend()
plt.grid(True)
plt.show()
q

#with metrics Example
import random


class Network:
    def __init__(self):
        self.nodes = set()
        self.links = {}

    def add_node(self, node):
        self.nodes.add(node)

    def add_link(self, node1, node2, cost, latency, throughput, packet_loss):
        self.links[(node1, node2)] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }
        self.links[(node2, node1)] = {
            'cost': cost,
            'latency': latency,
            'throughput': throughput,
            'packet_loss': packet_loss
        }

    def get_neighbors(self, node):
        neighbors = []
        for link in self.links:
            if link[0] == node:
                neighbors.append(link[1])
            elif link[1] == node:
                neighbors.append(link[0])
        return neighbors

    def get_link_cost(self, node1, node2):
        return self.links[(node1, node2)]['cost']

    def get_link_latency(self, node1, node2):
        return self.links[(node1, node2)]['latency']

    def get_link_throughput(self, node1, node2):
        return self.links[(node1, node2)]['throughput']

    def get_link_packet_loss(self, node1, node2):
        return self.links[(node1, node2)]['packet_loss']


class AntColonyOptimization:
    def __init__(self, network, num_ants, evaporation_rate, alpha, beta, pheromone_init):
        self.network = network
        self.num_ants = num_ants
        self.evaporation_rate = evaporation_rate
        self.alpha = alpha
        self.beta = beta
        self.pheromone_init = pheromone_init
        self.pheromone_matrix = None

    def initialize_pheromone_matrix(self):
        self.pheromone_matrix = {}
        for node1 in self.network.nodes:
            self.pheromone_matrix[node1] = {}
            for node2 in self.network.nodes:
                if node1 == node2:
                    self.pheromone_matrix[node1][node2] = 0.0
                else:
                    self.pheromone_matrix[node1][node2] = self.pheromone_init

    def update_pheromone_matrix(self, ant_routes):
        for node1 in self.network.nodes:
            for node2 in self.network.nodes:
                if node1 != node2:
                    self.pheromone_matrix[node1][node2] *= (1 - self.evaporation_rate)
        for route in ant_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i + 1]
                pheromone = 1.0 / (
                        self.network.get_link_cost(node1, node2) *
                        self.network.get_link_latency(node1, node2) *
                        self.network.get_link_throughput(node1, node2) *
                        (1.0 - self.network.get_link_packet_loss(node1, node2))
                )
                self.pheromone_matrix[node1][node2] += pheromone

    def select_next_node(self, ant, current_node, available_nodes):
        probabilities = []
        total = 0.0
        for node in available_nodes:
            pheromone = self.pheromone_matrix[current_node][node]
            cost = self.network.get_link_cost(current_node, node)
            latency = self.network.get_link_latency(current_node, node)
            throughput = self.network.get_link_throughput(current_node, node)
            packet_loss = self.network.get_link_packet_loss(current_node, node)
            probability = (
                    (pheromone ** self.alpha) *
                    ((1.0 / cost) ** self.beta) *
                    ((1.0 / latency) ** self.beta) *
                    (throughput ** self.alpha) *
                    ((1.0 - packet_loss) ** self.alpha)
            )
            probabilities.append(probability)
            total += probability
        probabilities = [p / total for p in probabilities]
        selected_index = self.roulette_wheel_selection(probabilities)
        return available_nodes[selected_index]

    def roulette_wheel_selection(self, probabilities):
        cumulative_probabilities = [sum(probabilities[:i + 1]) for i in range(len(probabilities))]
        random_value = random.uniform(0, 1)
        for i in range(len(cumulative_probabilities)):
            if random_value <= cumulative_probabilities[i]:
                return i

    def find_shortest_path(self, source, destination):
        shortest_path = None
        shortest_distance = float('inf')
        for ant in range(self.num_ants):
            current_node = source
            visited_nodes = set([source])
            path = [source]
            distance = 0
            while current_node != destination:
                available_nodes = list(set(self.network.get_neighbors(current_node)) - visited_nodes)
                if not available_nodes:
                    break
                next_node = self.select_next_node(ant, current_node, available_nodes)
                distance += self.network.get_link_cost(current_node, next_node)
                current_node = next_node
                visited_nodes.add(current_node)
                path.append(current_node)
            if current_node == destination and distance < shortest_distance:
                shortest_distance = distance
                shortest_path = path
        return shortest_path, shortest_distance


class PerformanceMetrics:
    @staticmethod
    def calculate_end_to_end_delay(path, network):
        total_delay = 0
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            latency = network.get_link_latency(node1, node2)
            total_delay += latency
        return total_delay

    @staticmethod
    def calculate_network_congestion(path, network):
        max_throughput = float('inf')
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i + 1]
            throughput = network.get_link_throughput(node1, node2)
            if throughput < max_throughput:
                max_throughput = throughput
        return max_throughput




# Define the network topology with latency, throughput, and packet loss information
network = Network()
network.add_node('A')
network.add_node('B')
network.add_node('C')
network.add_node('D')
network.add_node('E')
network.add_node('F')
network.add_node('G')
network.add_node('H')

network.add_link('A', 'B', cost=2, latency=10, throughput=100, packet_loss=0.05)
network.add_link('A', 'C', cost=4, latency=15, throughput=200, packet_loss=0.1)
network.add_link('B', 'C', cost=3, latency=12, throughput=150, packet_loss=0.07)
network.add_link('B', 'D', cost=2, latency=8, throughput=120, packet_loss=0.03)
network.add_link('C', 'D', cost=1, latency=5, throughput=180, packet_loss=0.02)
network.add_link('D', 'E', cost=3, latency=9, throughput=160, packet_loss=0.08)
network.add_link('D', 'F', cost=4, latency=13, throughput=140, packet_loss=0.04)
network.add_link('E', 'F', cost=2, latency=7, throughput=130, packet_loss=0.06)
network.add_link('E', 'G', cost=3, latency=11, throughput=110, packet_loss=0.09)
network.add_link('F', 'G', cost=1, latency=6, throughput=170, packet_loss=0.03)
network.add_link('A', 'H', cost=3, latency=9, throughput=120, packet_loss=0.05)


# Create and run Ant Colony Optimization
aco = AntColonyOptimization(network, num_ants=9, evaporation_rate=0.5, alpha=1.0, beta=2.0, pheromone_init=0.1)
aco.initialize_pheromone_matrix()
shortest_path, shortest_distance = aco.find_shortest_path('G', 'H')

# Print the shortest path and distance
if shortest_path is not None:
    print("Shortest Path:", ' -> '.join(shortest_path))
    print("Shortest Distance:", shortest_distance)

    # Calculate performance metrics
    end_to_end_delay = PerformanceMetrics.calculate_end_to_end_delay(shortest_path, network)
    network_congestion = PerformanceMetrics.calculate_network_congestion(shortest_path, network)

    print("End-to-End Delay:", end_to_end_delay)
    print("Network Congestion:", network_congestion)
else:
    print("Destination is unreachable.")

#Graph Plotting Example
import networkx as nx
import matplotlib.pyplot as plt

# Create an empty graph
G = nx.Graph()

# Add nodes
nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
G.add_nodes_from(nodes)

edges = [
    ('A', 'B', {'cost': 2, 'latency': 10, 'throughput': 100, 'packet_loss': 0.05}),
    ('A', 'C', {'cost': 4, 'latency': 15, 'throughput': 200, 'packet_loss': 0.1}),
    ('B', 'C', {'cost': 3, 'latency': 12, 'throughput': 150, 'packet_loss': 0.07}),
    ('B', 'D', {'cost': 2, 'latency': 8, 'throughput': 120, 'packet_loss': 0.03}),
    ('C', 'D', {'cost': 1, 'latency': 5, 'throughput': 180, 'packet_loss': 0.02}),
    ('D', 'E', {'cost': 3, 'latency': 9, 'throughput': 160, 'packet_loss': 0.08}),
    ('D', 'F', {'cost': 4, 'latency': 13, 'throughput': 140, 'packet_loss': 0.04}),
    ('E', 'F', {'cost': 2, 'latency': 7, 'throughput': 130, 'packet_loss': 0.06}),
    ('E', 'G', {'cost': 3, 'latency': 11, 'throughput': 110, 'packet_loss': 0.09}),
    ('F', 'G', {'cost': 1, 'latency': 6, 'throughput': 170, 'packet_loss': 0.03})
]
G.add_edges_from(edges)

fig = plt.figure(figsize=(20, 12))
pos = nx.spring_layout(G)
edge_labels = {(u, v): f"Cost: {d['cost']}\nLatency: {d['latency']}\nThroughput: {d['throughput']}\nPacket Loss: {d['packet_loss']}" for u, v, d in G.edges(data=True)}
nx.draw_networkx(G, pos, with_labels=True, node_color='skyblue', node_size=1000, edge_color='gray', width=1.5)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')
plt.axis('off')

node_colors = ['red' if node in ['A', 'G'] else 'skyblue' for node in G.nodes()]
nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=1000)
plt.show()